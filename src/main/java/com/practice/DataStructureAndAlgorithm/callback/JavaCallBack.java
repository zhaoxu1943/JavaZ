package com.practice.DataStructureAndAlgorithm.callback;

/**
 * 概念都是针对调用者来说的
 * 同步,异步
 * 同步调用:调用者发起一个同步调用时,在没有得到结果之前,调用不返回
 * 如顺序代码,如果说func结果没有返回,next就不会执行
 * int n = func();
 * next();
 *
 * 异步调用:在发出一个异步调用时,调用者不会立即得到结果,该调用就返回了
 * func(callback);
 * next();
 * ...
 *
 * void callback(int n)     // func 结果回调
 * {
 *   int k = n;
 * }
 * 这段中的func()执行后,还没得出结果就立即返回,然后执行next();
 * 等到结果出来,func调用callback 通知调用者结果
 *
 * 阻塞:
 * 调用者发起一个阻塞调用,调用者会进入阻塞状态,只有得到结果才会返回
 * //如socket server中的accept,直到connection建立都是blocked的,程序就停在 recv() 这里等待
 * 后面的代码都不会执行了
 * //The method blocks until a connection is made.
 *                     Socket socket = serverSocket.accept();
 *
 *如果线程始终阻塞着，永远得不到资源，于是就发生了死锁。
 *
 *
 * 非阻塞调用则是不能立即得到结果之前,该函数不会阻塞当前线程,而会立即返回
 *  比如非阻塞socket 的 send()，调用这个函数，它只是把待发送的数据复制到TCP输出缓冲区中
 *  就立刻返回了，线程并不会阻塞，数据有没有发出去 send() 是不知道的，不会等待它发出去才返回的。
 *
 * 同步的定义看起来跟阻塞很像，但是同步跟阻塞是两个概念，同步调用的时候，线程不一定阻塞，
 * 调用虽然没返回，但它还是在运行状态中的，CPU很可能还在执行这段代码，而阻塞的话，
 * 它就肯定不在CPU中跑这个代码了。这就是同步和阻塞的区别。同步是可以在CPU，阻塞是肯定不在CPU。
 *
 * 异步和非阻塞的定义比较像，两者的区别是异步是说调用的时候结果不会马上返回，
 * 线程可能被阻塞起来，也可能不阻塞，两者没关系。非阻塞是说调用的时候，线程肯定不会进入阻塞状态。
 *
 * 同步阻塞调用：得不到结果不返回，线程进入阻塞态等待。
 * 同步非阻塞调用：得不到结果不返回，线程不阻塞一直在CPU运行。
 * 异步阻塞调用：去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞。
 * 异步非阻塞调用：去到别的线程，别的线程一直在运行，直到得出结果。
 *
 *
 *
 *
 * callback 是一种异步操作手段
 * 吃饭排队 是同步的, 拿号是异步的
 *
 * callback回调只是稍后执行的函数
 * 回调往往就意味着是异步,而异步就需要时间等待,也就是它是将来要发生,而不是现在立刻马上,它会稍后执行
 *
 * @author zhaoxu
 * @className JavaCallBack
 * @projectName JavaConcentration
 * @date 2020/5/29 12:13
 */
public class JavaCallBack {
}
